
provider "aws" {
  region     = var.aws_region
  access_key = var.aws_access_key
  secret_key = var.aws_secret_key
}

resource "aws_ssm_parameter" "twitch_bot_oauth_token" {
  name  = "/bottwitch/bot_oauth_token"
  type  = "SecureString"
  value = var.twitch_bot_oauth_token
}

resource "aws_ssm_parameter" "twitch_bot_refresh_token" {
  name  = "/bottwitch/bot_refresh_token"
  type  = "SecureString"
  value = var.twitch_bot_refresh_token
}

resource "aws_ssm_parameter" "twitch_client_id" {
  name  = "/bottwitch/client_id"
  type  = "String"
  value = var.twitch_client_id
}

resource "aws_ssm_parameter" "twitch_client_secret" {
  name  = "/bottwitch/client_secret"
  type  = "SecureString"
  value = var.twitch_client_secret
}

resource "aws_ssm_parameter" "twitch_bot_access_token" {
  name  = "/bottwitch/bot_access_token"
  type  = "SecureString"
  value = var.twitch_bot_access_token
}

resource "aws_ssm_parameter" "twitch_channel_name" {
  name  = "/bottwitch/channel_name"
  type  = "String"
  value = var.twitch_channel_name
}

resource "aws_ssm_parameter" "twitch_channel_id" {
  name  = "/bottwitch/channel_id"
  type  = "String"
  value = var.twitch_channel_id
}

resource "aws_ssm_parameter" "mongodb_connection_string" {
  name  = "/botmongodb/connection_string"
  type  = "SecureString"
  value = var.mongodb_connection_string
}

# 2. AWS SQS Queues

resource "aws_sqs_queue" "input_queue" {
  name                      = "twitch-input-queue"
  visibility_timeout_seconds = 30
}

resource "aws_sqs_queue" "output_queue" {
  name                      = "twitch-output-queue"
  visibility_timeout_seconds = 30
}

# SSM Parameters for SQS Queue URLs

resource "aws_ssm_parameter" "sqs_input_queue_url" {
  name  = "/botaws/input_queue_url"
  type  = "String"
  value = aws_sqs_queue.input_queue.id
}

resource "aws_ssm_parameter" "sqs_output_queue_url" {
  name  = "/botaws/output_queue_url"
  type  = "String"
  value = aws_sqs_queue.output_queue.id
}

# 3. IAM Role and Instance Profile for EC2

resource "aws_iam_role" "ec2_role" {
  name = "twitch_bot_ec2_role"

  assume_role_policy = jsonencode({
    Version = "2012-10-17",
    Statement = [{
      Action = "sts:AssumeRole",
      Effect = "Allow",
      Principal = {
        Service = "ec2.amazonaws.com"
      }
    }]
  })
}

resource "aws_iam_role_policy_attachment" "ec2_role_attach" {
  role       = aws_iam_role.ec2_role.name
  policy_arn = aws_iam_policy.ec2_policy.arn
}

resource "aws_iam_policy" "ec2_policy" {
  name = "twitch_bot_ec2_policy"

  policy = jsonencode({
    Version = "2012-10-17",
    Statement = [
      {
        Action = [
          "ssm:GetParameter",
          "ssm:GetParameters",
          "ssm:GetParametersByPath",
          "ssm:DescribeParameters",
          "ssm:PutParameter"
        ],
        Effect   = "Allow",
        Resource = "*"
      },
      {
        Action = [
          "sqs:*",
          "ssm:*",
          "logs:*",
          "ecr:*",
          "secretsmanager:GetSecretValue",
          "ec2:DescribeVpcs",
          "ec2:DescribeSubnets",
          "ec2:DescribeImages",
          "ec2:DescribeRouteTables"
        ],
        Effect   = "Allow",
        Resource = "*"
      }
    ]
  })
}

resource "aws_iam_instance_profile" "ec2_instance_profile" {
  name = "twitch_bot_instance_profile"
  role = aws_iam_role.ec2_role.name
}

# 4. Security Group

resource "aws_security_group" "ec2_sg" {
  name        = "twitch_bot_sg"
  description = "Security group for Twitch Bot EC2 instance"
  vpc_id      = data.aws_vpc.default.id

  ingress {
    from_port   = 22
    to_port     = 22
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }
}

data "aws_vpc" "default" {
  default = true
}

# 5. EC2 Instance

resource "aws_instance" "twitch_bot_ec2" {
  ami                         = data.aws_ami.ubuntu.id
  instance_type               = "t3.micro"
  subnet_id                   = data.aws_subnets.default.ids[0]  # Use the first subnet
  associate_public_ip_address = true
  key_name                    = var.key_pair_name
  iam_instance_profile        = aws_iam_instance_profile.ec2_instance_profile.name
  security_groups             = [aws_security_group.ec2_sg.id]

  user_data = file("user_data.sh")

  tags = {
    Name = "TwitchBotEC2"
  }
}

data "aws_ami" "ubuntu" {
  most_recent = true
  owners      = ["099720109477"]

  filter {
    name   = "name"
    values = ["ubuntu/images/hvm-ssd/ubuntu-focal-20.04-amd64-server-*"]
  }
}

data "aws_subnets" "default" {
  filter {
    name   = "vpc-id"
    values = [data.aws_vpc.default.id]
  }
}

output "ssm_parameters" {
  value = [
    aws_ssm_parameter.twitch_bot_oauth_token.name,
    aws_ssm_parameter.twitch_client_id.name,
    aws_ssm_parameter.twitch_client_secret.name,
    aws_ssm_parameter.twitch_bot_access_token.name,
    aws_ssm_parameter.twitch_channel_name.name,
    aws_ssm_parameter.twitch_channel_id.name,
    aws_ssm_parameter.mongodb_connection_string.name,
    aws_ssm_parameter.sqs_input_queue_url.name,
    aws_ssm_parameter.sqs_output_queue_url.name
  ]
}

output "sqs_queue_urls" {
  value = {
    input_queue_url  = aws_sqs_queue.input_queue.id
    output_queue_url = aws_sqs_queue.output_queue.id
  }
}

output "ec2_public_ip" {
  value = aws_instance.twitch_bot_ec2.public_ip
}
#!/bin/bash
set -e  # Exit on any error

# Enable logging
exec > >(tee /var/log/user_data.log|logger -t user_data) 2>&1

# Update packages and install Docker
apt-get update -y
apt-get install -y docker.io docker-compose git

# Start Docker service
systemctl start docker
systemctl enable docker

# Clone the repository
mkdir -p /home/ubuntu/twitch_bot
cd /home/ubuntu/twitch_bot

# Replace with your actual repository URL
git clone https://github.com/jjkant/tbot.git . || { echo "Git clone failed"; exit 1; }

# Navigate to the processing folder
cd processing

# Run Docker Compose
docker-compose up -d || { echo "Docker Compose failed"; exit 1; }

echo "Twitch bot setup completed successfully!"
variable "aws_region" {
  description = "AWS Region to deploy resources"
  type        = string
  default     = "eu-west-1"
}

variable "aws_access_key" {
  description = "AWS Access Key for authentication"
  type        = string
  sensitive   = true
}

variable "aws_secret_key" {
  description = "AWS Secret Key for authentication"
  type        = string
  sensitive   = true
}

variable "twitch_bot_oauth_token" {
  description = "OAuth token for the Twitch bot."
  type        = string
}

variable "twitch_client_id" {
  description = "Twitch application client ID."
  type        = string
}

variable "twitch_client_secret" {
  description = "Twitch application client secret."
  type        = string
}

variable "twitch_bot_refresh_token" {
  description = "Refresh token for the Twitch bot."
  type        = string
}

variable "twitch_bot_access_token" {
  description = "Access token for Twitch API calls."
  type        = string
}

variable "twitch_channel_name" {
  description = "Name of your Twitch channel."
  type        = string
}

variable "twitch_channel_id" {
  description = "ID of your Twitch channel."
  type        = string
}

variable "mongodb_connection_string" {
  description = "Connection string for MongoDB Atlas."
  type        = string
}

variable "key_pair_name" {
  description = "Name of the AWS EC2 Key Pair."
  type        = string
}
# action_handler.py

import os
import boto3
import json
from twitchAPI.twitch import Twitch
from twitchAPI.types import AuthScope
from twitchAPI.oauth import refresh_access_token

def get_parameters():
    ssm = boto3.client('ssm', region_name='eu-west-1')
    params = ssm.get_parameters(
        Names=[
            '/botaws/output_queue_url',
            '/bottwitch/client_id',
            '/bottwitch/client_secret',
            '/bottwitch/bot_refresh_token',
            '/bottwitch/channel_id'
        ],
        WithDecryption=True
    )
    return {param['Name']: param['Value'] for param in params['Parameters']}

params = get_parameters()

sqs = boto3.client('sqs', region_name='eu-west-1')
output_queue_url = params['/botaws/output_queue_url']

client_id = params['/bottwitch/client_id']
client_secret = params['/bottwitch/client_secret']
channel_id = params['/bottwitch/channel_id']
bot_refresh_token = params['/bottwitch/bot_refresh_token']

# Refresh the access token
new_tokens = refresh_access_token(
    bot_refresh_token,
    client_id,
    client_secret
)

bot_access_token = new_tokens['access_token']
bot_refresh_token = new_tokens['refresh_token']

# Update the refresh token in SSM Parameter Store
ssm = boto3.client('ssm', region_name='eu-west-1')
ssm.put_parameter(
    Name='/bottwitch/bot_refresh_token',
    Value=bot_refresh_token,
    Type='SecureString',
    Overwrite=True
)

# Initialize Twitch API client
twitch = Twitch(client_id, client_secret)
twitch.set_user_authentication(
    bot_access_token,
    [
        AuthScope.CHAT_EDIT,
        AuthScope.CHAT_READ,
        AuthScope.MODERATOR_MANAGE_CHAT_MESSAGES,
        AuthScope.USER_MANAGE_WHISPERS,
        AuthScope.MODERATOR_READ_CHATTERS,
        AuthScope.USER_READ_EMAIL
    ],
    bot_refresh_token
)

def handle_actions():
    while True:
        response = sqs.receive_message(
            QueueUrl=output_queue_url,
            MaxNumberOfMessages=10,
            WaitTimeSeconds=20
        )
        messages = response.get('Messages', [])
        for msg in messages:
            body = json.loads(msg['Body'])
            username = body['username']
            is_allowed = body['is_allowed']
            message_id = body.get('message_id')

            if not is_allowed:
                try:
                    # Get user_id from username
                    users = twitch.get_users(logins=[username])
                    user_data = users['data'][0] if users['data'] else None
                    if user_data:
                        user_id = user_data['id']

                        # Delete the user's message
                        if message_id:
                            # If message_id is available, delete specific message
                            twitch.delete_chat_messages(
                                broadcaster_id=channel_id,
                                moderator_id=channel_id,  # Assuming the bot is a moderator
                                message_id=message_id
                            )
                        else:
                            # Otherwise, delete all messages from user
                            twitch.delete_chat_messages(
                                broadcaster_id=channel_id,
                                moderator_id=channel_id,
                                user_id=user_id
                            )

                        # Send a whisper to the user
                        twitch.send_whisper(
                            from_user_id=channel_id,
                            to_user_id=user_id,
                            message="Your message was deleted because you're not allowed to chat."
                        )
                    else:
                        print(f"User {username} not found.")
                except Exception as e:
                    print(f"Error processing user {username}: {e}")

            # Delete message from output queue
            sqs.delete_message(
                QueueUrl=output_queue_url,
                ReceiptHandle=msg['ReceiptHandle']
            )

if __name__ == '__main__':
    handle_actions()
# Dockerfile for Action Handler Service

FROM python:3.9-slim

WORKDIR /app

COPY action_handler.py /app
COPY requirements.txt /app

RUN pip install --no-cache-dir -r requirements.txt

CMD ["python", "action_handler.py"]
version: '3.3'

services:
  event_poller:
    build:
      context: ./event_poller
    container_name: event_poller
    restart: always
    logging:
      driver: awslogs
      options:
        awslogs-group: twitch-bot-logs
        awslogs-region: eu-west-1
        awslogs-stream: event_poller

  eligibility_processor:
    build:
      context: ./eligibility_processor
    container_name: eligibility_processor
    restart: always
    logging:
      driver: awslogs
      options:
        awslogs-group: twitch-bot-logs
        awslogs-region: eu-west-1
        awslogs-stream: eligibility_processor

  action_handler:
    build:
      context: ./action_handler
    container_name: action_handler
    restart: always
    logging:
      driver: awslogs
      options:
        awslogs-group: twitch-bot-logs
        awslogs-region: eu-west-1
        awslogs-stream: action_handler
# Dockerfile for Eligibility Processor Service

FROM python:3.9-slim

WORKDIR /app

COPY eligibility_processor.py /app
COPY requirements.txt /app

RUN pip install --no-cache-dir -r requirements.txt

CMD ["python", "eligibility_processor.py"]
# eligibility_processor.py

import os
import boto3
import json
from pymongo import MongoClient

def get_parameters():
    ssm = boto3.client('ssm', region_name='eu-west-1')
    params = ssm.get_parameters(
        Names=[
            '/botaws/input_queue_url',
            '/botaws/output_queue_url',
            '/botmongodb/connection_string'
        ],
        WithDecryption=True
    )
    return {param['Name']: param['Value'] for param in params['Parameters']}

params = get_parameters()

sqs = boto3.client('sqs', region_name='eu-west-1')
input_queue_url = params['/botaws/input_queue_url']
output_queue_url = params['/botaws/output_queue_url']

mongo_client = MongoClient(params['/botmongodb/connection_string'])
db = mongo_client['twitch_bot']
allowed_users_collection = db['allowed_users']

def process_messages():
    while True:
        response = sqs.receive_message(
            QueueUrl=input_queue_url,
            MaxNumberOfMessages=10,
            WaitTimeSeconds=20
        )
        messages = response.get('Messages', [])
        for msg in messages:
            body = json.loads(msg['Body'])
            username = body['username']

            # Check if user is allowed to chat using username
            user_record = allowed_users_collection.find_one({'username': username})
            is_allowed = user_record is not None

            result = {
                'username': username,
                'message': body['message'],
                'timestamp': body['timestamp'],
                'message_id': body.get('message_id'),
                'is_allowed': is_allowed
            }

            # Send result to output queue
            sqs.send_message(
                QueueUrl=output_queue_url,
                MessageBody=json.dumps(result)
            )

            # Delete message from input queue
            sqs.delete_message(
                QueueUrl=input_queue_url,
                ReceiptHandle=msg['ReceiptHandle']
            )

if __name__ == '__main__':
    process_messages()
# Dockerfile for Message Poller Service

FROM python:3.9-slim

WORKDIR /app

COPY event_poller.py /app
COPY requirements.txt /app

RUN pip install --no-cache-dir -r requirements.txt

CMD ["python", "event_poller.py"]
# event_poller.py

import os
import asyncio
from twitchio.ext import commands
import boto3
import json

def get_parameters():
    ssm = boto3.client('ssm', region_name='eu-west-1')
    params = ssm.get_parameters(
        Names=[
            '/bottwitch/bot_oauth_token',
            '/bottwitch/client_id',
            '/bottwitch/channel_name',
            '/botaws/input_queue_url'
        ],
        WithDecryption=True
    )
    return {param['Name']: param['Value'] for param in params['Parameters']}

params = get_parameters()

sqs = boto3.client('sqs', region_name='eu-west-1')
queue_url = params['/botaws/input_queue_url']

class TwitchBot(commands.Bot):

    def __init__(self):
        super().__init__(
            token=params['/bottwitch/bot_oauth_token'],
            client_id=params['/bottwitch/client_id'],
            nick='YourBotNick',
            prefix='!',
            initial_channels=[params['/bottwitch/channel_name']]
        )

    async def event_ready(self):
        print(f"Logged in as | {self.nick}")

    async def event_message(self, message):
        if message.echo:
            return

        # Get message_id if available
        message_id = message.tags.get('id')  # Message ID

        msg_data = {
            'username': message.author.name,
            'message': message.content,
            'timestamp': str(message.timestamp),
            'message_id': message_id
        }

        # Send message data to SQS
        sqs.send_message(
            QueueUrl=queue_url,
            MessageBody=json.dumps(msg_data)
        )

if __name__ == '__main__':
    bot = TwitchBot()
    bot.run()
