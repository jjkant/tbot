import json
import os
import time
import boto3
from pymongo import MongoClient
import requests

def lambda_handler(event, context):
    if event['httpMethod'] != 'POST':
        return {
            'statusCode': 405,
            'body': json.dumps({'error': 'Method Not Allowed'}),
            'headers': {
                'Content-Type': 'application/json'
            }
        }

    try:
        body = json.loads(event['body'])
        client_id = body['client_id']
        client_secret = body['client_secret']
        auth_code = body['code']
    except (json.JSONDecodeError, KeyError) as e:
        return {
            'statusCode': 400,
            'body': json.dumps({'error': 'Invalid request body'}),
            'headers': {
                'Content-Type': 'application/json'
            }
        }

    redirect_uri = os.environ['FRONTEND_CALLBACK_URL']  # Must match the redirect URI used in the OAuth flow

    # Exchange authorization code for tokens
    token_url = "https://id.twitch.tv/oauth2/token"
    payload = {
        'client_id': client_id,
        'client_secret': client_secret,
        'code': auth_code,
        'grant_type': 'authorization_code',
        'redirect_uri': redirect_uri
    }

    response = requests.post(token_url, data=payload)
    if response.status_code != 200:
        return {
            'statusCode': 500,
            'body': json.dumps({'error': 'Failed to exchange authorization code.'}),
            'headers': {
                'Content-Type': 'application/json'
            }
        }

    token_data = response.json()
    access_token = token_data['access_token']
    refresh_token = token_data['refresh_token']
    expires_in = token_data['expires_in']

    # Update MongoDB
    mongo_uri = os.environ['MONGODB_CONNECTION_STRING']
    client = MongoClient(mongo_uri)
    db = client['twitch_bot']
    config_collection = db['config']

    config_collection.update_one(
        {'_id': 'twitch_user_tokens'},
        {
            '$set': {
                'client_id': client_id,
                'client_secret': client_secret,
                'access_token': access_token,
                'refresh_token': refresh_token,
                'expires_in': expires_in,
                'obtained_at': int(time.time())
            }
        },
        upsert=True
    )

    # Response to the user
    return {
        'statusCode': 200,
        'body': json.dumps({'message': 'Tokens successfully updated in MongoDB. You can now close this window.'}),
        'headers': {
            'Content-Type': 'application/json'
        }
    }
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Authorization Callback</title>
</head>
<body>
  <h1>Completing Authorization...</h1>
  <p>Please wait while we complete the setup.</p>

  <script>
    (async () => {
      // Get the authorization code from the URL
      const params = new URLSearchParams(window.location.search);
      const authCode = params.get('code');
      if (!authCode) {
        document.body.innerHTML = "<p>Error: No authorization code found.</p>";
        return;
      }

      // Retrieve the client ID and client secret from session storage
      const clientId = sessionStorage.getItem('twitch_client_id');
      const clientSecret = sessionStorage.getItem('twitch_client_secret');

      if (!clientId || !clientSecret) {
        document.body.innerHTML = "<p>Error: Client ID or Client Secret not found. Please restart the process.</p>";
        return;
      }

      // Send the data to the Lambda function via POST request
      try {
        const response = await fetch("{{LAMBDA_FUNCTION_URL}}", {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            client_id: clientId,
            client_secret: clientSecret,
            code: authCode
          })
        });

        const result = await response.json();
        if (response.ok) {
          document.body.innerHTML = "<p>Success: " + result.message + "</p>";
        } else {
          document.body.innerHTML = "<p>Error: " + result.error + "</p>";
        }
      } catch (error) {
        document.body.innerHTML = "<p>Error: " + error.message + "</p>";
      }
    })();
  </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Twitch Bot Authorization</title>
</head>
<body>
  <h1>Authorize Your Twitch Bot</h1>
  <p>Enter your Twitch Client ID and Client Secret below:</p>
  <form id="auth-form">
    <label for="client-id">Client ID:</label><br>
    <input type="text" id="client-id" name="client-id" required><br><br>
    <label for="client-secret">Client Secret:</label><br>
    <input type="password" id="client-secret" name="client-secret" required><br><br>
    <button type="submit">Authorize</button>
  </form>

  <script>
    document.getElementById("auth-form").addEventListener("submit", (event) => {
      event.preventDefault();

      const clientId = document.getElementById("client-id").value;
      const clientSecret = document.getElementById("client-secret").value;
      const redirectUri = "{{FRONTEND_CALLBACK_URL}}"; // Will be replaced via Terraform
      const scopes = [
        "chat:read",
        "chat:edit",
        "whispers:read",
        "whispers:edit",
        "moderator:manage:banned_users"
      ].join(" ");

      // Store client ID and client secret in session storage
      sessionStorage.setItem("twitch_client_id", clientId);
      sessionStorage.setItem("twitch_client_secret", clientSecret);

      const authUrl = `https://id.twitch.tv/oauth2/authorize?client_id=${clientId}&redirect_uri=${encodeURIComponent(
        redirectUri
      )}&response_type=code&scope=${encodeURIComponent(scopes)}`;

      window.location.href = authUrl;
    });
  </script>
</body>
</html>
# main.tf

provider "aws" {
  region     = var.aws_region
  access_key = var.aws_access_key
  secret_key = var.aws_secret_key
}

# 1. AWS SSM Parameters

# Store MongoDB connection string in AWS SSM Parameter Store
resource "aws_ssm_parameter" "mongodb_connection_string" {
  name  = "/botmongodb/connection_string"
  type  = "SecureString"
  value = var.mongodb_connection_string
}

# 2. AWS SQS Queues

resource "aws_sqs_queue" "input_queue" {
  name                       = "twitch-input-queue"
  visibility_timeout_seconds = 30
}

resource "aws_sqs_queue" "output_queue" {
  name                       = "twitch-output-queue"
  visibility_timeout_seconds = 30
}

# SSM Parameters for SQS Queue URLs

resource "aws_ssm_parameter" "sqs_input_queue_url" {
  name  = "/botaws/input_queue_url"
  type  = "String"
  value = aws_sqs_queue.input_queue.id
}

resource "aws_ssm_parameter" "sqs_output_queue_url" {
  name  = "/botaws/output_queue_url"
  type  = "String"
  value = aws_sqs_queue.output_queue.id
}

# 3. IAM Role and Instance Profile for EC2

resource "aws_iam_role" "ec2_role" {
  name = "twitch_bot_ec2_role"

  assume_role_policy = jsonencode({
    Version = "2012-10-17",
    Statement = [{
      Action = "sts:AssumeRole",
      Effect = "Allow",
      Principal = {
        Service = "ec2.amazonaws.com"
      }
    }]
  })
}

resource "aws_iam_policy" "ec2_policy" {
  name = "twitch_bot_ec2_policy"

  policy = jsonencode({
    Version = "2012-10-17",
    Statement = [
      {
        Action = [
          "ssm:GetParameter",
          "ssm:GetParameters",
          "ssm:GetParametersByPath",
          "ssm:DescribeParameters"
        ],
        Effect   = "Allow",
        Resource = "*"
      },
      {
        Action = [
          "sqs:*",
          "logs:*",
          "ec2:DescribeVpcs",
          "ec2:DescribeSubnets",
          "ec2:DescribeImages",
          "ec2:DescribeRouteTables"
        ],
        Effect   = "Allow",
        Resource = "*"
      }
    ]
  })
}

resource "aws_iam_role_policy_attachment" "ec2_role_attach" {
  role       = aws_iam_role.ec2_role.name
  policy_arn = aws_iam_policy.ec2_policy.arn
}

resource "aws_iam_instance_profile" "ec2_instance_profile" {
  name = "twitch_bot_instance_profile"
  role = aws_iam_role.ec2_role.name
}

# 4. Security Group

data "aws_vpc" "default" {
  default = true
}

resource "aws_security_group" "ec2_sg" {
  name        = "twitch_bot_sg"
  description = "Security group for Twitch Bot EC2 instance"
  vpc_id      = data.aws_vpc.default.id

  ingress {
    from_port   = 22
    to_port     = 22
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]  # Consider restricting SSH access to specific IPs
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }
}

# 5. EC2 Instance

data "aws_ami" "ubuntu" {
  most_recent = true
  owners      = ["099720109477"]  # Canonical

  filter {
    name   = "name"
    values = ["ubuntu/images/hvm-ssd/ubuntu-focal-20.04-amd64-server-*"]
  }
}

data "aws_subnets" "default" {
  filter {
    name   = "vpc-id"
    values = [data.aws_vpc.default.id]
  }
}

resource "aws_instance" "twitch_bot_ec2" {
  ami                         = data.aws_ami.ubuntu.id
  instance_type               = "t3.micro"
  subnet_id                   = data.aws_subnets.default.ids[0]  # Use the first subnet
  associate_public_ip_address = true
  key_name                    = var.key_pair_name
  iam_instance_profile        = aws_iam_instance_profile.ec2_instance_profile.name
  security_groups             = [aws_security_group.ec2_sg.id]

  user_data = file("user_data.sh")

  tags = {
    Name = "TwitchBotEC2"
  }
}
# Update Lambda Function Environment Variables
resource "aws_lambda_function" "oauth_handler" {
  filename         = "lambda_package.zip"  # The deployment package
  function_name    = "${var.project_name}_oauth_handler"
  role             = aws_iam_role.lambda_role.arn
  handler          = "lambda_function.lambda_handler"
  runtime          = "python3.9"
  timeout          = 10
  publish          = true

  environment {
    variables = {
      MONGODB_CONNECTION_STRING = var.mongodb_connection_string
      FRONTEND_CALLBACK_URL     = "${aws_s3_bucket.frontend_bucket.website_endpoint}/auth_callback.html"
    }
  }
}

# Update the S3 Bucket Objects to process templates
# Upload index.html
resource "aws_s3_bucket_object" "index_html" {
  bucket       = aws_s3_bucket.frontend_bucket.id
  key          = "index.html"
  content      = templatefile("${path.module}/frontend/index.html", {
    FRONTEND_CALLBACK_URL = "${aws_s3_bucket.frontend_bucket.website_endpoint}/auth_callback.html"
  })
  content_type = "text/html"
  acl          = "public-read"
}

# Upload auth_callback.html
resource "aws_s3_bucket_object" "auth_callback_html" {
  bucket       = aws_s3_bucket.frontend_bucket.id
  key          = "auth_callback.html"
  content      = templatefile("${path.module}/frontend/auth_callback.html", {
    LAMBDA_FUNCTION_URL = aws_lambda_function_url.oauth_handler_url.function_url
  })
  content_type = "text/html"
  acl          = "public-read"
}


# Outputs

output "ssm_parameters" {
  value = [
    aws_ssm_parameter.mongodb_connection_string.name,
    aws_ssm_parameter.sqs_input_queue_url.name,
    aws_ssm_parameter.sqs_output_queue_url.name
  ]
}

output "sqs_queue_urls" {
  value = {
    input_queue_url  = aws_sqs_queue.input_queue.id
    output_queue_url = aws_sqs_queue.output_queue.id
  }
}

output "ec2_public_ip" {
  value = aws_instance.twitch_bot_ec2.public_ip
}



output "ssm_parameters" {
  value = [
    aws_ssm_parameter.mongodb_connection_string.name,
    aws_ssm_parameter.sqs_input_queue_url.name,
    aws_ssm_parameter.sqs_output_queue_url.name
  ]
}

output "sqs_queue_urls" {
  value = {
    input_queue_url  = aws_sqs_queue.input_queue.id
    output_queue_url = aws_sqs_queue.output_queue.id
  }
}

output "ec2_public_ip" {
  value = aws_instance.twitch_bot_ec2.public_ip
}
output "frontend_website_url" {
  value = aws_s3_bucket.frontend_bucket.website_endpoint
}

output "lambda_function_url" {
  value = aws_lambda_function_url.oauth_handler_url.function_url
}
# variables.tf

variable "aws_region" {
  description = "AWS Region to deploy resources"
  type        = string
  default     = "eu-west-1"
}

variable "aws_access_key" {
  description = "AWS Access Key for authentication"
  type        = string
  sensitive   = true
}

variable "aws_secret_key" {
  description = "AWS Secret Key for authentication"
  type        = string
  sensitive   = true
}

variable "mongodb_connection_string" {
  description = "Connection string for MongoDB Atlas."
  type        = string
}

variable "key_pair_name" {
  description = "Name of the AWS EC2 Key Pair."
  type        = string
}
# action_handler.py

import os
import boto3
import json
import time
from twitchAPI.twitch import Twitch
from twitchAPI.oauth import refresh_access_token
from twitchAPI.types import AuthScope
from pymongo import MongoClient

def get_ssm_parameters():
    ssm = boto3.client('ssm', region_name='eu-west-1')
    parameter_names = [
        '/botaws/output_queue_url',
        '/botmongodb/connection_string'
    ]
    response = ssm.get_parameters(
        Names=parameter_names,
        WithDecryption=True
    )
    params = {param['Name']: param['Value'] for param in response['Parameters']}
    return params

def get_mongo_config(mongo_connection_string):
    # Connect to MongoDB
    mongo_client = MongoClient(mongo_connection_string)
    db = mongo_client['twitch_bot']
    config_collection = db['config']
    return config_collection

def get_twitch_credentials(config_collection):
    # Fetch Twitch App Credentials
    app_credentials = config_collection.find_one({'_id': 'twitch_app_credentials'})
    if not app_credentials:
        raise Exception("Twitch app credentials not found in MongoDB.")

    # Fetch User Tokens
    user_tokens = config_collection.find_one({'_id': 'twitch_user_tokens'})
    if not user_tokens:
        raise Exception("Twitch user tokens not found in MongoDB.")

    # Fetch Bot Configuration
    bot_config = config_collection.find_one({'_id': 'bot_config'})
    if not bot_config:
        raise Exception("Bot configuration not found in MongoDB.")

    return app_credentials, user_tokens, bot_config

def update_user_tokens(config_collection, new_tokens):
    new_tokens['expires_in'] = new_tokens.get('expires_in', 3600)
    new_tokens['obtained_at'] = int(time.time())
    config_collection.update_one(
        {'_id': 'twitch_user_tokens'},
        {'$set': new_tokens}
    )

def refresh_token_if_needed(app_credentials, user_tokens, config_collection):
    current_time = int(time.time())
    token_age = current_time - user_tokens['obtained_at']
    if token_age >= user_tokens['expires_in'] - 300:  # Refresh 5 minutes before expiration
        print("Refreshing access token...")
        new_tokens = refresh_access_token(
            user_tokens['refresh_token'],
            app_credentials['client_id'],
            app_credentials['client_secret']
        )
        update_user_tokens(config_collection, new_tokens)
        return new_tokens['access_token']
    else:
        return user_tokens['access_token']

def main():
    ssm_params = get_ssm_parameters()
    output_queue_url = ssm_params['/botaws/output_queue_url']
    mongo_connection_string = ssm_params['/botmongodb/connection_string']

    config_collection = get_mongo_config(mongo_connection_string)
    app_credentials, user_tokens, bot_config = get_twitch_credentials(config_collection)
    access_token = refresh_token_if_needed(app_credentials, user_tokens, config_collection)

    # Initialize Twitch API client
    twitch = Twitch(app_credentials['client_id'], app_credentials['client_secret'])
    twitch.set_user_authentication(
        access_token,
        [
            AuthScope.CHAT_EDIT,
            AuthScope.CHAT_READ,
            AuthScope.MODERATOR_MANAGE_CHAT_MESSAGES,
            AuthScope.USER_MANAGE_WHISPERS,
            AuthScope.MODERATOR_READ_CHATTERS,
            AuthScope.USER_READ_EMAIL,
            AuthScope.MODERATOR_MANAGE_BANNED_USERS
        ],
        user_tokens['refresh_token']
    )

    # Fetch channel ID
    channel_name = bot_config['channel_name']
    user_info = twitch.get_users(logins=[channel_name])
    if user_info['data']:
        channel_id = user_info['data'][0]['id']
    else:
        raise Exception(f"Channel {channel_name} not found.")

    sqs = boto3.client('sqs', region_name='eu-west-1')

    while True:
        response = sqs.receive_message(
            QueueUrl=output_queue_url,
            MaxNumberOfMessages=10,
            WaitTimeSeconds=20
        )
        messages = response.get('Messages', [])
        for msg in messages:
            body = json.loads(msg['Body'])
            event_type = body.get('event_type')
            username = body['username']
            is_allowed = body['is_allowed']

            try:
                # Get user_id from username
                users = twitch.get_users(logins=[username])
                user_data = users['data'][0] if users['data'] else None
                if user_data:
                    user_id = user_data['id']
                else:
                    print(f"User {username} not found.")
                    continue

                if not is_allowed:
                    # Timeout user for 10 hours (36,000 seconds)
                    try:
                        twitch.ban_user(
                            broadcaster_id=channel_id,
                            moderator_id=channel_id,  # Assuming the bot is a moderator
                            user_id=user_id,
                            reason="You are not allowed to chat in this channel.",
                            duration=36000  # 10 hours in seconds
                        )
                        print(f"User {username} has been timed out for 10 hours.")
                    except Exception as e:
                        print(f"Error timing out user {username}: {e}")

                    # Send a whisper to the user
                    try:
                        twitch.send_whisper(
                            from_user_id=channel_id,
                            to_user_id=user_id,
                            message="You have been timed out for 10 hours because you're not allowed to chat."
                        )
                        print(f"Whisper sent to user {username}.")
                    except Exception as e:
                        print(f"Error sending whisper to user {username}: {e}")
                else:
                    # User is allowed; no action needed
                    pass
            except Exception as e:
                print(f"Error processing user {username}: {e}")

            # Delete message from output queue
            sqs.delete_message(
                QueueUrl=output_queue_url,
                ReceiptHandle=msg['ReceiptHandle']
            )

if __name__ == '__main__':
    main()
# Dockerfile for Action Handler Service

FROM python:3.9-slim

WORKDIR /app

COPY action_handler.py /app
COPY requirements.txt /app

RUN pip install --no-cache-dir -r requirements.txt

CMD ["python", "action_handler.py"]
version: '3.3'

services:
  event_poller:
    build:
      context: ./event_poller
    container_name: event_poller
    restart: always
    logging:
      driver: awslogs
      options:
        awslogs-group: twitch-bot-logs
        awslogs-region: eu-west-1
        awslogs-stream: event_poller

  eligibility_processor:
    build:
      context: ./eligibility_processor
    container_name: eligibility_processor
    restart: always
    logging:
      driver: awslogs
      options:
        awslogs-group: twitch-bot-logs
        awslogs-region: eu-west-1
        awslogs-stream: eligibility_processor

  action_handler:
    build:
      context: ./action_handler
    container_name: action_handler
    restart: always
    logging:
      driver: awslogs
      options:
        awslogs-group: twitch-bot-logs
        awslogs-region: eu-west-1
        awslogs-stream: action_handler
# Dockerfile for Eligibility Processor Service

FROM python:3.9-slim

WORKDIR /app

COPY eligibility_processor.py /app
COPY requirements.txt /app

RUN pip install --no-cache-dir -r requirements.txt

CMD ["python", "eligibility_processor.py"]
# eligibility_processor.py

import os
import boto3
import json
from pymongo import MongoClient

def get_ssm_parameters():
    ssm = boto3.client('ssm', region_name='eu-west-1')
    parameter_names = [
        '/botaws/input_queue_url',
        '/botaws/output_queue_url',
        '/botmongodb/connection_string'
    ]
    response = ssm.get_parameters(
        Names=parameter_names,
        WithDecryption=True
    )
    params = {param['Name']: param['Value'] for param in response['Parameters']}
    return params

def main():
    ssm_params = get_ssm_parameters()
    input_queue_url = ssm_params['/botaws/input_queue_url']
    output_queue_url = ssm_params['/botaws/output_queue_url']
    mongo_connection_string = ssm_params['/botmongodb/connection_string']

    # Connect to MongoDB
    mongo_client = MongoClient(mongo_connection_string)
    db = mongo_client['twitch_bot']
    allowed_users_collection = db['allowed_users']

    sqs = boto3.client('sqs', region_name='eu-west-1')

    while True:
        response = sqs.receive_message(
            QueueUrl=input_queue_url,
            MaxNumberOfMessages=10,
            WaitTimeSeconds=20
        )
        messages = response.get('Messages', [])
        for msg in messages:
            body = json.loads(msg['Body'])
            event_type = body.get('event_type')
            username = body['username']

            # Check if user is allowed to chat using username
            user_record = allowed_users_collection.find_one({'username': username})
            is_allowed = user_record is not None

            result = {
                'event_type': event_type,
                'username': username,
                'is_allowed': is_allowed
            }

            if event_type == 'message':
                result.update({
                    'message': body['message'],
                    'timestamp': body['timestamp'],
                    'message_id': body.get('message_id')
                })
            elif event_type == 'join':
                result.update({
                    'timestamp': body['timestamp']
                })

            # Send result to output queue
            sqs.send_message(
                QueueUrl=output_queue_url,
                MessageBody=json.dumps(result)
            )

            # Delete message from input queue
            sqs.delete_message(
                QueueUrl=input_queue_url,
                ReceiptHandle=msg['ReceiptHandle']
            )

if __name__ == '__main__':
    main()
# Dockerfile for Message Poller Service

FROM python:3.9-slim

WORKDIR /app

COPY event_poller.py /app
COPY requirements.txt /app

RUN pip install --no-cache-dir -r requirements.txt

CMD ["python", "event_poller.py"]
# event_poller.py

import os
import asyncio
import datetime
import time
from twitchio.ext import commands
import boto3
import json
from pymongo import MongoClient
from twitchAPI.oauth import refresh_access_token

def get_ssm_parameters():
    ssm = boto3.client('ssm', region_name='eu-west-1')
    parameter_names = [
        '/botaws/input_queue_url',
        '/botmongodb/connection_string'
    ]
    response = ssm.get_parameters(
        Names=parameter_names,
        WithDecryption=True
    )
    params = {param['Name']: param['Value'] for param in response['Parameters']}
    return params

def get_mongo_config(mongo_connection_string):
    # Connect to MongoDB
    mongo_client = MongoClient(mongo_connection_string)
    db = mongo_client['twitch_bot']
    config_collection = db['config']
    return config_collection

def get_twitch_credentials(config_collection):
    # Fetch Twitch App Credentials
    app_credentials = config_collection.find_one({'_id': 'twitch_app_credentials'})
    if not app_credentials:
        raise Exception("Twitch app credentials not found in MongoDB.")

    # Fetch User Tokens
    user_tokens = config_collection.find_one({'_id': 'twitch_user_tokens'})
    if not user_tokens:
        raise Exception("Twitch user tokens not found in MongoDB.")

    # Fetch Bot Configuration
    bot_config = config_collection.find_one({'_id': 'bot_config'})
    if not bot_config:
        raise Exception("Bot configuration not found in MongoDB.")

    return app_credentials, user_tokens, bot_config

def update_user_tokens(config_collection, new_tokens):
    new_tokens['expires_in'] = new_tokens.get('expires_in', 3600)
    new_tokens['obtained_at'] = int(time.time())
    config_collection.update_one(
        {'_id': 'twitch_user_tokens'},
        {'$set': new_tokens}
    )

def refresh_token_if_needed(app_credentials, user_tokens, config_collection):
    current_time = int(time.time())
    token_age = current_time - user_tokens['obtained_at']
    if token_age >= user_tokens['expires_in'] - 300:  # Refresh 5 minutes before expiration
        print("Refreshing access token...")
        new_tokens = refresh_access_token(
            user_tokens['refresh_token'],
            app_credentials['client_id'],
            app_credentials['client_secret']
        )
        update_user_tokens(config_collection, new_tokens)
        return new_tokens['access_token']
    else:
        return user_tokens['access_token']

def main():
    ssm_params = get_ssm_parameters()
    input_queue_url = ssm_params['/botaws/input_queue_url']
    mongo_connection_string = ssm_params['/botmongodb/connection_string']

    config_collection = get_mongo_config(mongo_connection_string)
    app_credentials, user_tokens, bot_config = get_twitch_credentials(config_collection)
    access_token = refresh_token_if_needed(app_credentials, user_tokens, config_collection)

    # Initialize the bot
    class TwitchBot(commands.Bot):

        def __init__(self):
            super().__init__(
                token=access_token,
                client_id=app_credentials['client_id'],
                nick=bot_config['bot_username'],
                prefix='!',
                initial_channels=[bot_config['channel_name']]
            )
            self.sqs = boto3.client('sqs', region_name='eu-west-1')
            self.queue_url = input_queue_url

        async def event_ready(self):
            print(f"Logged in as | {self.nick}")

        async def event_message(self, message):
            if message.echo:
                return

            # Get message_id if available
            message_id = message.tags.get('id')  # Message ID

            msg_data = {
                'event_type': 'message',
                'username': message.author.name,
                'message': message.content,
                'timestamp': str(message.timestamp),
                'message_id': message_id
            }

            # Send message data to SQS
            self.sqs.send_message(
                QueueUrl=self.queue_url,
                MessageBody=json.dumps(msg_data)
            )

        async def event_join(self, channel, user):
            if user.name.lower() == self.nick.lower():
                return  # Ignore when the bot joins
            msg_data = {
                'event_type': 'join',
                'username': user.name,
                'timestamp': datetime.datetime.utcnow().isoformat()
            }

            # Send join event data to SQS
            self.sqs.send_message(
                QueueUrl=self.queue_url,
                MessageBody=json.dumps(msg_data)
            )
            print(f"User {user.name} has joined the channel.")

    bot = TwitchBot()
    bot.run()

if __name__ == '__main__':
    main()
